h2
  if (place.data.Overall.total[2019].rank==1)
    | #[+value(place.name)] has the highest Health Index score across England 
  else if (place.data.Overall.total[2019].rank==307)
    | #[+value(place.name)] has the lowest Health Index score across England 
  else
    | Health in #[+value(place.name)]
    if ((place.data.Overall.total[2019].rank>122)&(place.data.Overall.total[2019].rank<185))
      | close to the national average
    else if (place.data.Overall.total[2019].rank>184)
      | top
      if (place.data.Overall.total[2019].rank/307 < 0.05)
        | #[+value(Math.ceil(place.data.Overall.total[2019].rank/307), {'FORMAT': '0%'})]
      else if (place.data.Overall.total[2019].rank/307 < 0.1)
        | #[+value(0.1, {'FORMAT': '0%'})]
      else if (place.data.Overall.total[2019].rank/307 < 0.2)
        | #[+value(0.2, {'FORMAT': '0%'})]
      else if (place.data.Overall.total[2019].rank/307 < 0.25)
        | #[+value(0.25, {'FORMAT': '0%'})]
      else if (place.data.Overall.total[2019].rank/307 < 0.3)
        | #[+value(0.3, {'FORMAT': '0%'})]    
      else if (place.data.Overall.total[2019].rank/307 < 0.4)
        | #[+value(0.4, {'FORMAT': '0%'})]
      else if (place.data.Overall.total[2019].rank/307 < 0.5)
        | #[+value(0.5, {'FORMAT': '0%'})]
    else if (place.data.Overall.total[2019].rank>185)
      | bottom
      if ((1-(place.data.Overall.total[2019].rank/307))<0.05)
        | #[+value(1-(place.data.Overall.total[2019].rank/307), {'FORMAT': '0%'})]
      else if ((1-(place.data.Overall.total[2019].rank/307))<0.1)
        | #[+value(0.1, {'FORMAT': '0%'})]
      else if ((1-(place.data.Overall.total[2019].rank/307))<0.2)
        | #[+value(0.2, {'FORMAT': '0%'})]
      else if ((1-(place.data.Overall.total[2019].rank/307))<0.25)
        | #[+value(0.25, {'FORMAT': '0%'})]
      else if ((1-(place.data.Overall.total[2019].rank/307))<0.3)
        | #[+value(0.3, {'FORMAT': '0%'})]
      else if ((1-(place.data.Overall.total[2019].rank/307))<0.4)
        | #[+value(0.4, {'FORMAT': '0%'})]
      else if ((1-(place.data.Overall.total[2019].rank/307))<0.5)
        | #[+value(0.5, {'FORMAT': '0%'})]
    | across England

p#subhead
  - var cha1 = place.data.Overall.total[2019].value - place.data.Overall.total[2018].value
  | #[+value(place.name)]'s Health Index score
  if ( Math.abs(cha1) < 0.3 )
    | remained relatively stable in the year before the coronavirus pandemic.
  else
    if ( cha1 < 0 )
      | decreased
    else
      | increased
    if ( Math.abs(cha1) > 2 )
      | considerably
    else if ( Math.abs(cha1) < 0.8 )
      | slightly
    | in the year before the coronavirus pandemic

div#co-box
  if (place.data.Overall.total[2019].value>100)
    div#callout-bigno4d
      p
        | #[+value(place.data.Overall.total[2019].value, {'FORMAT': '0.0'})]
  else
    div#callout-bigno3d
      p
        | #[+value(place.data.Overall.total[2019].value)]
  div#callout-text
    p
      - var locChange = place.data.Overall.total[2019].value - place.data.Overall.total[2018].value
      - var engChange = england.data.Overall.total[2019].value - england.data.Overall.total[2018].value
      | #[+value(place.name)] has an overall Health Index score of #[+value(place.data.Overall.total[2019].value, {'FORMAT': '0.0'})];
      | #[+value((cha1<0)? 'down' : 'up' )]
      | #[+value(Math.abs(locChange), {'FORMAT': '0.0'})] 
      | points compared to the previous year.

div#co-box
  div#callout-bigno3d
    p
      | #[+value(place.data.Overall.total[2019].rank, {'ORDINAL_NUMBER':true })]
  div#callout-text
    p
      | The area is ranked
      if (place.data.Overall.total[2019].rank != 1)
        | #[+value(place.data.Overall.total[2019].rank, {'ORDINAL_NUMBER':true })]
      | most healthy out of 307 local authority areas in England,
      | according to newly released data from 2019.

p#score
  | A score of 100 equates to the average across England when the index was first calculated in 2015.

mixin firstrank(i, met)
  if (Math.abs(sto[i][met])>5)
    | !{place.name}'s score for health relating to #[+value((sto[i].metric).toLowerCase())] is 
    if ( sto[i]['value'] > england.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[2019].value + 1 )
      | above
    else if ( sto[i]['value'] < england.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[2019].value - 1 )
      | below 
    else
      | close to
    | the average across England
  else
    | #[+value(place.name)]
    | has !{parent}'s
    if (Math.abs(sto[i][met+"_Reg"])!=1)
      | #[+value(Math.abs(sto[i][met+"_Reg"]), {'ORDINAL_TEXTUAL':true})]
    if (sto[i][met]>0)
      if (negs.includes((sto[i].metric).toLowerCase()))
        | best score for
      else
        | highest score for
    else
      if (negs.includes((sto[i].metric).toLowerCase()))
        | worst score for
      else
        | lowest score for
    | health relating to #[+value((sto[i].metric).toLowerCase())]

mixin firstchange(i, met)
  | #[+value(place.name)]
  if (Math.abs(sto[i][met])>5)
    | 's Health Index value for #[+value((sto[i].metric).toLowerCase())]
    if (sto[i][met.split(" ")[0]] > 0)
      | improved
    else
      | declined
    if (met=="Change1year Rank")
      | by #[+value(Math.abs(sto[i]['Change1year']))] points
      | between 2018 and 2019
    else if (met=="Change4year Rank")
      | by #[+value(Math.abs(sto[i]['Change4year']))] points
      | in the four years between 2015 and 2019
  else
    | saw Englandâ€™s
    if (Math.abs(sto[i][met])>1)
      | #[+value(Math.abs(sto[i][met]), {'ORDINAL_TEXTUAL':true})]
    | greatest #[+value((sto[i][met]>0)?'improvement':'decline')] in
    | health relating to #[+value((sto[i].metric).toLowerCase())]

mixin firstfirst(i, met)
  | Health in #[+value(place.name)] is strongest among measures relating to the #[+value((sto[i].metric).toLowerCase())] subdomain

mixin firstSen(i, met)
  if (i==0)
    | #[+firstfirst(i, met)]
  else if (met=="rank")
    | #[+firstrank(i, met)]
  else
    | #[+firstchange(i, met)]

mixin subdA(i)
  | #[+value(sto[i].metric)]
  | is a subdomain of
  | #[+value(domLU[sto[i].metric])]
  | which looks at
  eachz indic in indLU[sto[i].metric] with { separator:',', last_separator:'and' }
    | #[+value(uncap(indic))]
  | .

mixin subdB(i)
  | A subdomain of
  | #[+value(domLU[sto[i].metric])],
  | #[+value(sto[i].metric.toLowerCase())] addresses
  eachz indic in indLU[sto[i].metric] with { separator:',', last_separator:'and' }
    | #[+value(uncap(indic))]
  | .

mixin subd(i)
  synz {mode:'sequence'}
    syn
      | #[+subdA(i, met)]
    syn
      | #[+subdB(i, met)]

mixin accessfirst(i)
  | #[+value(place.name)] has a Health Index score of 
  | #[+value(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[2019].value, {'FORMAT': '0.0'})]
  | for #[+value(sto[i].metric.toLowerCase())]. 
  | The average across #[+value(parent)] is 
  | #[+value(region.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[2019].value, {'FORMAT': '0.0'})],
  | while England has a score of 
  | #[+value(england.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[2019].value, {'FORMAT': '0.0'})].

mixin access(i)
  | #[+value(place.name)] scored particularly low for
  | #[+value(indiSort(indis[sto[i].metric], -1, 'rank')[0])]
  | , with an index value of 
  | #[+value(indiSort(indis[sto[i].metric], -1, 'rank')[1])].
  if ( ['Access to services'].includes(sto[i].metric) )
    | The highest scoring indicator for this subdomain is 
    | #[+value(indiSort(indis[sto[i].metric], 0, 'rank')[0])]
    | , which has an index value of 
    | #[+value(indiSort(indis[sto[i].metric], 0, 'rank')[1])].
  else 
    | The index value for
    | #[+value(indiSort(indis[sto[i].metric], 0, 'rank')[0])]
    | is
    | #[+value(indiSort(indis[sto[i].metric], 0, 'rank')[1])].

mixin topBot(i, yr)
  if (Math.abs(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[yr].rank/307) > 0.4)
    | close to average
  else
    if (place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[yr].rank>0)
      | top
    else
      | bottom
    if (Math.abs(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[yr].rank/307) < 0.05)
      | #[+value((Math.ceil(Math.abs(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[yr].rank)*100/307)/100), {'FORMAT': '0%'})]
    else if (Math.abs(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[yr].rank/307) < 0.1)
      | #[+value(0.1, {'FORMAT': '0%'})]
    else if (Math.abs(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[yr].rank/307) < 0.15)
      | #[+value(0.15, {'FORMAT': '0%'})]
    else if (Math.abs(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[yr].rank/307) < 0.2)
      | #[+value(0.2, {'FORMAT': '0%'})]
    else if (Math.abs(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[yr].rank/307) < 0.25)
      | #[+value(0.25, {'FORMAT': '0%'})]
    else if (Math.abs(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[yr].rank/307) < 0.3)
      | #[+value(0.3, {'FORMAT': '0%'})]
    else if (Math.abs(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[yr].rank/307) < 0.4)
      | #[+value(0.4, {'FORMAT': '0%'})]
    else if (Math.abs(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[yr].rank/307) < 0.5)
      | #[+value(0.5, {'FORMAT': '0%'})]

mixin secondSenfirst(i, met)
  | #[+value(place.name)]'s highest score across all subdomains is 
  | #[+value(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[2019].value, {'FORMAT': '0.0'})]
  | for health relating to #[+value(sto[i].metric.toLowerCase())].

mixin secondSenA(i, met)
  | Between #[+value((met=="Change1year Rank")?'2018':'2015')] and 2019,
  | #[+value(place.name)]'s health index value for #[+value(sto[i].metric.toLowerCase())] went from 
  if (met=="Change1year Rank")
    | #[+value(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[2018].value, {'FORMAT': '0.0'})]
  else
    | #[+value(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[2015].value, {'FORMAT': '0.0'})]
  | to #[+value(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[2019].value, {'FORMAT': '0.0'})].
  | This means #[+value(place.name)]
  if (met=="Change1year Rank")
    if ( topbotnp(i, 2018, sto) != topbotnp(i, 2019, sto) )
      | went from #[+topBot(i, 2018)] to
    else
      | remained in the
    | #[+topBot(i, 2019)] 
  else
    if ( topbotnp(i, 2015, sto) != topbotnp(i, 2019, sto) )
      | went from #[+topBot(i, 2015)] to
    else
      | remained in the
    | #[+topBot(i, 2019)]
  |for this subdomain.


mixin secondSenB(i, met)
  - var subcha = place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[2019].value - ((met=="Change1year Rank")?place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[2018].value:place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[2015].value)
  | #[+value(place.name)]'s score for #[+value(sto[i].metric.toLowerCase())] 
  | #[+value( (subcha>0)? "rose" : "fell" )]
  | from 
  if (met=="Change1year Rank")
    | #[+value(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[2018].value, {'FORMAT': '0.0'})] in 2018
  else
    | #[+value(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[2015].value, {'FORMAT': '0.0'})] in 2015
  | to #[+value(place.data[domLU[sto[i].metric]].subdomains[sto[i].metric].total[2019].value, {'FORMAT': '0.0'})] in 2019.
  | This means #[+value(place.name)]
  if (met=="Change1year Rank")
    if ( topbotnp(i, 2018, sto) != topbotnp(i, 2019, sto) )
      | went from #[+topBot(i, 2018)] to
    else
      | remained in the
    | #[+topBot(i, 2019)] 
  else
    if ( topbotnp(i, 2015, sto) != topbotnp(i, 2019, sto) )
      | went from #[+topBot(i, 2015)] to
    else
      | remained in the
    | #[+topBot(i, 2019)]
  | across England for this subdomain.

mixin secondSen(i, met)
  synz {mode:'sequence'}
    syn
      | #[+secondSenB(i, met)]
    syn
      | #[+secondSenA(i, met)]


mixin declineImp(i, change, index, impDec)
  - var poscha = indiSort(indis[sto[i].metric], index, change)[1]
  - var negcha = indiSort(indis[sto[i].metric], (-1-index), change)[1]
  if ((impDec=="improvement")&(poscha>0.5))
    | #[+value((index!=0)?'and':'')]
    if (negs.includes(indiSort(indis[sto[i].metric], index, change)[0]))
      | a decline in
      | #[+value(indiSort(indis[sto[i].metric], index, change)[0])]
      | (index improved by #[+value(poscha)])
    else
      | improvements in
      | #[+value( indiSort(indis[sto[i].metric], index, change)[0] )]
      | (#[+value( poscha, {'FORMAT': '+0.0'})])
  else if (negcha<0.5)
    | #[+value((index!=0)?'and':'')]
    if (negs.includes(indiSort(indis[sto[i].metric], (-1-index), change)[0]))
      | an increase in
      | #[+value(indiSort(indis[sto[i].metric], (-1-index), change)[0])]
      | (index went down by #[+value(negcha, {'FORMAT': '+0.0'})])
    else
      | a decline in
      | #[+value(indiSort(indis[sto[i].metric], (-1-index), change)[0])]
      | (#[+value(negcha, {'FORMAT': '+0.0'})])

mixin however(i, change, impDec)
  if (impDec=="improvement")
    if ( indiSort(indis[sto[i].metric], -1, change)[1] < 0 )
      if (negs.includes(indiSort(indis[sto[i].metric], -1, change)[0]))
        | , however there was also an increase in
        | #[+value(indiSort(indis[sto[i].metric], -1, change)[0])]
        | (index worsened by #[+value(Math.abs(indiSort(indis[sto[i].metric], -1, change)[1]))] points)
      else
        | , however there was a decline in
        | #[+value(indiSort(indis[sto[i].metric], -1, change)[0])]
        | (#[+value(indiSort(indis[sto[i].metric], -1, change)[1], {'FORMAT': '+0.0'})])
  else
    if (indiSort(indis[sto[i].metric], -1, change)[1]>0)
      if (negs.includes(indiSort(indis[sto[i].metric], -1, change)[0]))
        | , however there was an improvement in
        | #[+value(indiSort(indis[sto[i].metric], 0, change)[0])]
        | (#[+value(indiSort(indis[sto[i].metric], 0, change)[1], {'FORMAT': '+0.0'})])
      else
        | , however there was an decrease in
        | #[+value(indiSort(indis[sto[i].metric], 0, change)[0])]
        | (#[+value(indiSort(indis[sto[i].metric], 0, change)[0], {'FORMAT': '+0.0'})])

mixin driven(i, change, impDec)
  | #[+declineImp(i, change, 0, impDec)]
  | #[+declineImp(i, change, 1, impDec)]
  | #[+however(i, change, impDec)]
  | .

mixin lastSen(i, met)
  - var imprDecl = (sto[i][met.split(" ")[0]]>0) ? 'improvement' : 'decline'
  | The change was largely driven by
  if (met=="Change1year Rank")
    | #[+driven(i, "Change1year", imprDecl)]
  else
    | #[+driven(i, "change4year", imprDecl)]

mixin chartTitle(i, met)
  | #[+firstSen(i, met)]

mixin chartSubTitle(i, met)
  if (i==0)
    | Health Index values for each subdomain in #[+value(place.name)], 2019
  else if (met=="rank")
    | Health Index values for the #[+value("&quot"+(sto[i].metric).toLowerCase()+"&quot")] subdomain 
    | across local authority areas in #[+value(parent)] and 
    | the average across England, 2019
  else 
    | Health Index values for the #[+value("&quot"+(sto[i].metric).toLowerCase()+"&quot")] subdomain, 
    | #[+value(place.name)], #[+value(parent)] and England,
    | 2015 - 2019

mixin thirdfirst(i, met)
  | The next highest scoring subdomain is #[+value(orda[1].metric.toLowerCase())], 
  | while #[+value(place.name)]'s worst score is for 
  | #[+value(orda[orda.length-1].metric.toLowerCase())].

mixin para(i, met)
  if (i == 0)
    p #[+secondSenfirst(i, met)]
    p #[+subd(i, met)]
    p #[+thirdfirst(i, met)]
  else if ( ['Access to green space', 'Access to services'].includes(sto[i].metric) )
    p #[+accessfirst(i, met)]
    p #[+subd(i, met)]
    p #[+access(i, met)]
  else
    p #[+subd(i, met)]
    p #[+secondSen(i, met)]
    p #[+lastSen(i, met)]

if (sto.length>0)
  - var met = whichMet(sto[0])
  if ( ['Access to green space', 'Access to services'].includes( sto[0].metric ) )
    - met = "rank"
  h4 #[+chartTitle(0, met)]
  h5 #[+chartSubTitle(0, met)]
  div#esc123
  div#catchthisdivforchart1
  div#legend1
  div#info1
  div#chart1
  div#source1
  p #[+para(0, met)]
  div.funky
if (sto.length>1)
  - var met = whichMet(sto[1])
  if ( ['Access to green space', 'Access to services'].includes( sto[1].metric ) )
    - met = "rank"
  h4 #[+chartTitle(1, met)]
  h5 #[+chartSubTitle(1, met)]
  div#esc123
  div#legend2
  div#info2
  div#chart2
  div#source2
  p #[+para(1, met)]
  div.funky
if (sto.length>2)
  - var met = whichMet(sto[2])
  if ( ['Access to green space', 'Access to services'].includes( sto[2].metric ) )
    - met = "rank"
  h4 #[+chartTitle(2, met)]
  h5 #[+chartSubTitle(2, met)]
  div#esc123
  div#legend3
  div#info3
  div#chart3
  div#source3
  p #[+para(2, met)]
  div.funky
if (sto.length>3)
  - var met = whichMet(sto[3])
  if ( ['Access to green space', 'Access to services'].includes( sto[3].metric ) )
    - met = "rank"
  h4 #[+chartTitle(3, met)]
  h5 #[+chartSubTitle(3, met)]
  div#esc123
  div#legend4
  div#info4
  div#chart4
  div#source4
  p #[+para(3, met)]
